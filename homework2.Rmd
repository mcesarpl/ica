```{r}
library(AppliedPredictiveModeling)
data(solubility)
library(lattice)
library(e1071)
library(caret)
```

initial plots

```{r}
xyplot(solTrainY ~ solTrainX$MolWeight, type = c("p","g"), ylab = "Solubility", xlab = "Mol Weight")
xyplot(solTrainY ~ solTrainX$SurfaceArea1, type = c("p","g"), ylab = "Solubility", xlab = "Surface Area 1")
bwplot(solTrainY ~ ifelse(solTrainX[,50] == 1, "presence", "absent"),ylab = "Solubility")
```


transformar apenas os FP

```{r}
#notfps = names(solTrainX)[209:228]
notfps = names(solTrainX)[!grepl("FP", names(solTrainX))]
train_X <- solTrainX[,notfps] + 1
test_X  <-  solTestX[,notfps] + 1
```

pre process

```{r}
solPP <- preProcess(train_X, method = "BoxCox")
predTrainX <- predict(solPP, train_X)
predTestX <- predict(solPP, test_X)
```



Junta os preditores e as variáveis transformadas

```{r}
solTrainTransX <- cbind(solTrainX[,grep("FP", names(solTrainX))],predTrainX)
solTestTransX <- cbind(solTestX[,grep("FP", names(solTestX))],predTestX)

```


```{r}
skewness(solTrainXtrans$NumAromaticBonds)
skewness(solTrainTransX$NumAromaticBonds)
```

regressão linear


```{r}

folds = createFolds(solTrainY, k = 5, returnTrain = TRUE)
ctrl_folds = trainControl(method = "cv", index = folds, number = 5)
lmTrain = train(x = solTrainTransX,y = solTrainY, method = "lm", trControl = ctrl_folds, preProcess = c("BoxCox"))

lmTrain

```



model tuning

```{r}
correlated1 = findCorrelation(cor(solTrainTransX), .9)
correlated2 = findCorrelation(cor(solTestTransX), .9)
filteredTrainX <- solTrainTransX[,-correlated1]
filteredTestX <- solTestTransX[,-correlated2]

lmTrainTune <- train(x = filteredTrainX, y = solTrainY, method = "lm", trControl = ctrl_folds)

lmTrainTune
```


define rsquared

```{r}
rsq <- function (x, y) cor(x, y) ^ 2
```



```{r}
pred_ = predict(lmTrainTune,solTestXtrans)
head(pred_)
postResample(solTestY,pred_)
RMSE(solTestY,pred_)
lmTrainTune$resample
```



```{r}
resultados = data.frame(obs = solTestY, pred = pred_)
defaultSummary(resultados)
```


use the training transformed predictor to learn either PCR or PLS and test using test set

```{r}
custom_folds = createFolds(solTrainY, k = 5, returnTrain = TRUE)
custom_tcl = trainControl(method = "cv", index = custom_folds, number = 5)
pls_ = train(x = solTrainTransX, y = solTrainY, method = "pls", trControl = custom_tcl, preProcess =  c("BoxCox"), tuneLength = 5)

resultPls = predict(pls_,solTestXtrans)
frame_pls = data.frame(obs = solTestY, pred = resultPls)
defaultSummary(frame_pls)

#RMSE(solTestY,plsPred)
#postResample(solTrainXtrans,plsResults)


```

```{r}


```



Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.
